
Created <font style="color:tomato; font-family:Consolas;">24-09-2024</font> 
 
Tags: #electronics #arduino #pwm

Related: NIL

****

## Principle

The digital pins on the Arduino can only be toggled between 5V (HIGH) and 0V (LOW). So how do we achieve an intermediate voltage between 0-5V, to control, say, the brightness of an LED?

By switching the pin between 0V and 5V *really* fast, the pin can supply an "average voltage".

The example below shows the pin being turned on 50% of one period. When this is done at a high frequency, the output will be the average voltage, which is 50% of 5V = 2.5V.

![[Pasted image 20240924195644.png]]

If we connect a LED between this pin and ground, we are turning the LED on half the time, and off the other half. At low frequencies, we just see the LED blinking; But when this happens sufficiently quickly (>30Hz), the flickering of the LED will be too fast for our eyes to catch and we just perceive it as being "half as bright".

>The 30Hz mentioned here is the threshold frequency for the persistence of vision effect in humans. Our eyes and brain retain a visual impression for ~1/30 of a second, so if the LED is blinking more than 30 times per second (30Hz), we perceive it as a continuous, intermediate brightness.

Another example with the pin turned on 25% of a period, which produces 25% of 5V = 1.25V.

![[Pasted image 20240924200030.png]]

The percentage of time the pin is turned 'on' is known as the **duty cycle**. We can control the output voltage by adjusting this parameter:

$$ Duty\; cycle=\frac{T_{ON}}{T_{ON}+T_{OFF}} \times 100\% $$
$$ V_{out}=Duty\; cycle \times V_{ON}$$

## PWM resolution

PWM resolution is the number of bits used to represent the duty cycle value. It is the number of discrete levels which the PWM duty cycle could be set to between 0-100%.

The Arduino uses 8-bit PWM. This means that there are $2^8=256$ subdivisions between 0-100% which the duty cycle could be adjusted to.

Let's say we want to slowly increase the brightness of an LED using PWM. If we choose a 3-bit PWM, there would only be $2^3=8$ "steps" between 0-100%, and the process of turning on the LED will look very choppy since there are only 8 discrete brightness levels the LED can display. If we increase the resolution to say 7-bits, there would instead be $2^7=128$ "steps", and hence 128 discrete levels of brightness the LED can display when transitioning from unlit to fully lit, which looks much smoother.

So is it optimal to just make the PWM resolution as high as possible? To answer that, we first need to understand how microcontrollers generate PWM.

## Generating PWM

You may think that PWM is generated by turning the pin 'on' and 'off' for specific periods of time in software, but this is actually not desirable despite being plausible. 

PWM generation is often handled by special hardware registers and interrupts instead.

>Registers are memory locations built into the processor itself, making it extremely accessible but also limited in storage size. Hardware registers are special registers where each bit stored in these registers modifies the state of some hardware. For instance, saving the binary 1001 in the PORTB register of an Arduino UNO turns pins 8, 11 on.

### Timers

Every microcontroller has built-in timers and an internal or external resonator which sets the frequency of operation. The Arduino UNO, for example, operates at 16Mhz and has 3 hardware timers. By default, these timers will increment it's stored value by 1 every clock tick.

These hardware timers could be configured to count in a different manners. Below is some basic timer knowledge:

1) **Size**: the maximum number of bits the timer register can hold. For the Arduino UNO, it has 2x 8-bit timers and 1x 16-bit timer.

2) **Pre-scalar**: how many internal clock ticks before counting up by 1. Sometimes we don't want the timers so count so fast, so we can set it to count up by 1 for every 8 clock ticks etc.

3) **TOP value:** a TOP value is a premature endpoint that could be specified. The TOP value is set to the size of each timer by default; E.g an 8-bit timer will have a TOP of 255 by default, but we can manually set it to say 156 instead, and it will only count till 156 before resetting.

4) **Mode:** how the timer behaves after reaching TOP value (also called a timer overflow). By default, the timer will restart from 0 and count up again. It could be configured such that the timer starts counting down instead, or restart from a set value instead of 0.

### Interrupts

Interrupts are signals that temporarily halts the execution of the main program to tend to some time-sensitive tasks or respond to external events. For example, we can enable an interrupt when data is received from a sensor on the Arduino. The Arduino will pause the main code and read the sensor values during the interrupt routine, and resume once it finishes.

There are specific interrupt registers that could turn a pin `ON` or `OFF` based on an event. In the case of PWM generation, we can set some interrupt register to trigger when the timer counts to a specific value.

### Working together

This is how we setup a pin to generate 8-bit PWM using only hardware timers and interrupts:

1) Choose an 8-bit timer and set it's mode to reset on overflow. We will choose `timer2` on the Arduino UNO since it is 8-bit.

2) Enable an interrupt register to **toggle** the pin state whenever `timer2` reaches a specific value `n` , and also when reaching the TOP value.

The flow of events is as follows:

1) `timer2` counts upwards from 0

2) When the `timer2` value matches `n`, the interrupt register is triggered and the pin state is toggled

3) `timer2` continues counting, and when it reaches it's TOP value, the interrupt register is triggered again and the pin state is toggled

4) `timer2` overflows and starts counting from 0 again.

The graph below shows `timer2`  counting from 0 to it's TOP value (255 default), and the interrupt value `n`.

![[Pasted image 20240924213433.png]]

Below is the resulting voltage output from the pin being toggled `ON` and `OFF`. 

![[Pasted image 20240924213930.png]]

Now let's change the interrupt value `n` to a larger value:

![[Pasted image 20240924214020.png]]

We can hence generate a variable PWM signal by adjusting the interrupt compare value `n`.

$$Duty\; cycle=\frac{n}{TOP}\times 100\%$$

## Frequency

The frequency of the PWM signal depends on the period of 1 cycle. We can see from the previous section that the period is basically the time taken for the timer to count from 0-TOP. Hence, we can adjust the frequency of the PWM signal by changing how fast the timer counts.

We also mentioned earlier that we can configure a pre-scaler for the timers. Pre-scalers divide the core clock ticks by a specific amount before feeding it to the timer.

For example, the Arduino UNO has a core clock speed of 16MHz. `timer1`  has a pre-scaler of 0 by default, counting up by 1 for **every clock tick**. if we set a pre-scaler of 4 for `timer1`, it will increment it's value by 1 for **every 4 clock ticks** instead, essentially slowing it down by 4x.

The frequency of the PWM signal is hence calculated by

$$pwm\; freq.=\frac{core\; freq.}{(1+TOP)\times prescaler}$$

From the equation, we can see that the PWM frequency is inversely proportional to the TOP value. This is also the reason why a high PWM **resolution** is not always desirable since it lowers the maximum PWM frequency.

>The PWM frequency to control power electronics, such as switching power supply or chopper drives, is usually set above 30kHz to eliminate electrical noise. 30kHz is chosen since it is well above the upper limit of the human hearing range.

### Example: Calculating Arduino UNO PWM frequency

Let's say we want to generate an 8-bit PWM of around 30kHz on the Arduino UNO which runs at 16MHz. How do we configure the timers?

TOP value for 8-bit PWM : $2^8-1=255$ (We subtract 1 since the timer starts counting from 0, not 1)

Plug the desired frequency and TOP into the formula:

$$30\times 10^3=\frac{16\times 10^6}{(1+255)\times prescalar}$$
$$prescalar=\frac{16\times 10^6}{256\times 30\times 10^3}=2.083$$

However, we can only set integer pre-scalers, so we will use a pre-scalar of 2 instead.



