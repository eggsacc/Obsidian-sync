
Created <font style="color:tomato; font-family:Consolas;">01-12-2024</font>

Tags: 

Related: NIL

Sources: [Learn OpenGL - Hello Triangle](https://learnopengl.com/Getting-started/Hello-Triangle)

****

## Understanding the pipeline

>[!tip] Oops!
>OpenGL does not come with any predefined vertex and fragment shaders, so we have to write our own.

### 1) Vertex input

OpenGL is a 3D graphics library so all coordinates will be in 3D `(x, y, z)`. OpenGL does not simply transform **all** the coordinates into pixels on the screen, it only processes coordinates within the `x` and `y` range of `[-1, 1]`. Only coordinates within this so called **normalized device coordinates** will be visible, everything else is discarded.

We can specify a set of normalized coordinates (between -1 and 1) for the vertices of the triangle using a `float` array:

````cpp
float vertices[] = 
{
	-0.5f, -0.5f, 0.0f,
	0.5f, -0.5f, 0.0f,
	0.0f, 0.5f, 0.0f
};
````

![[Pasted image 20241201143616.png#invert]]

Now we want to send it as input to the first process in the pipeline: the vertex shader. We need to create memory on the GPU to store the vertex data, configure how OpenGL interprets the data, and specify how to send the data to the GPU.

A Vertex Buffer Object (VBO) is used to store a large number of vertices in GPU memory. Since sending data to the GPU is often quite slow, so we generally want to send the vertices in batches using a VBO for better performance.

Each VBO has a unique ID that is generated by OpenGL. `GLuint` is actually just `unsigned int`, but using this custom typedef standardizes the notation.

````cpp
GLuint VBO;
glGenBuffers(1, &VBO);
````

There are many buffer types available in OpenGL, but the buffer type for a VBO is always `GL_ARRAY_BUFFER`. We now need to bind the newly created VBO to the `GL_ARAY_BUFFER`.

````cpp
glBindBuffer(GL_ARRAY_BUFFER, VBO);
````

Binding a buffer makes it the current active buffer for subsequent operations. In other words, any subsequent functions that operates on the `GL_ARRAY_BUFFER` will use `VBO` instead.

Now we need to copy the previously defined vertex data into the buffer.

````cpp
glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
````

Note that the 4th parameter specifies how we want to manage the given data. There are 3 options:

1) `GL_STREAM_DRAW`: data is sent once and only used a few times by
2) `GL_STATIC_DRAW`: data is sent once and used many times
3) `GL_DYNAMIC_DRAW`: data is constantly changed and used many times

>[!info] Why do we need to specify the last parameter?
>These types serve as hints to OpenGL about how the buffer data will be used, and this information helps OpenGL optimize the placement and management of the data in GPU memory. For example, hinting the type `GL_STATIC_DRAW` will prompt OpenGL to place the data in GPU-local memory, which is fast for rendering but slow for updates. Changing it to the type `GL_DYNAMIC_DRAW` will prompt OpenGL to place the data in special memory locations optimized for frequent updates closer to the CPU.

In our case, the vertex coordinates of a triangle does not change, is used a lot, and stays the same for each render call so it is set to the type `GL_STATIC_DRAW`.

### 2) Vertex shader

The vertex shader has to be written in the shader language GLSL (OpenGL Shading Language) and compiled to machine code so it could be used in our code.

The source code for a very basic vertex shader is given below:

````cpp
#version 330 core
layout (location = 0) in vec3 aPos;

void main()
{
    gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);
}
````

In the code snippet, we create a `vec3` variable named `aPos`. `vec3` is a GLSL vector data type containing 1-4 floats based on the postfix digit. The `layout (location=0)` specifies the location of the shader VAA (vertex attribute array).

>[!info] GLSL vector
>The values in a `vec4` GLSL vector could be retrieved using `vec4.x`, `vec4.y`, `vec4.z` and `vec4.w`, where each value represents a 3D coordinate. The `vec4.w` component is used for perspective division (calculating distortion).

To set the output of the vertex shader we have to assign the position data to the predefine `gl_position` variable which is a `vec4` type. We can cast `aPos` of type `vec3` by extracting the individual `vec3.x/y/z` values and setting the last `vec4.w` to `1.0f`.

This is the most simple vertex shader since we are not doing any sort of transformation and just directly mapping the vertex coordinates to the shader output. Usually, this shader will scale the 3D coordinates of vertices into the viewport range of `[-1, 1]` along each axis.

#### Compiling shader
We store the source code of the shader as a `const C string` to be processed later. 

````cpp
const char *vertexShaderSource = "#version 330 core\n"
    "layout (location = 0) in vec3 aPos;\n"
    "void main()\n"
    "{\n"
    "   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"
    "}\0";
````

In order for OpenGL to use the shader, it has to dynamically compile it during runtime. We can create the vertex shader object and store its unique ID in an `unsigned int` or `GLuint`.

````cpp
GLuint vertexShader;
vertexShader = glCreateShader(GL_VERTEX_SHADER);
````

Next we attach the shader source code to the object and compile it.

````cpp
glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);
glCompileShader(vertexShader);
````


### 3) Fragment shader

The only other shader we have to create is the fragment shader. The purpose of this shader is to calculate the color of the output pixels. To keep things simple we will set it to always output a orange color.

````cpp
#version 330 core
out vec4 FragColor;

void main()
{
    FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);
} 
````

>[!info] RGBA
>Colors in computer graphics are represented in the RGBA format: red, green, blue and alpha (opacity), where each component is a value between `0.0` and `1.0`.

We now compile the fragment shader the same way as before.

````cpp
const char* fragmentShaderSource = "#version 330 core \n"
"out vec4 FragColor;\n"
"void main()\n"
"{\n"
"    FragColor = vec4(0.8f, 0.3f, 0.02f, 1.0f);\n"
"}\n\0";

GLuint fragmentShader;
fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);
glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);
glCompileShader(fragmentShader);
````


### 4) Shader program

Now that both the vertex and fragment shaders are compiled, all we have left to do is link both the shaders into a **shader program** that we can use for rendering.

A shader program is the combination of some shaders. When we issue render calls, it will activate all the shaders linked to the program. Each shader in a shader program has its output linked to the input of the next shader. Linking errors may arise if the output format does not match with the input format of another shader.

To create a program object:

````cpp
GLuint shaderProgram;
shaderProgram = glCreateProgram();
````

To link the previously created shaders:

````cpp
glAttachShader(shaderProgram, vertexShader);
glAttachShader(shaderProgram, fragmentShader);
glLinkProgram(shaderProgram);
````

Remember that the sequence we attach the shaders are important since the output of the `vertexShader` is fed as an input to `fragmentShader`.

Now we need to activate the program object.

````cpp
glUseProgram(shaderProgram);
````

Since the shaders has been linked, we are free to delete it.

````cpp
glDeleteShader(vertexShader);
glDeleteShader(fragmentShader);
````

At this point, we have send the input vertex data to the GPU and set up a series of instructions telling the GPU how to process the data using the shaders. However, OpenGL has no idea on how to interpret the data.

### 5) Linking vertex attributes

Since the vertex data consists of 3D coordinates stored in a `float` array, it has the following properties:

1) Each data (individual axis coordinate) occupies 4 bytes (`float`)
2) Each position (coordinate) is composed of 3 of those values `(x, y, z)`
3) The elements are contiguous in memory
4) The first value is at the beginning of the buffer

We can thus tell OpenGL how to interpret it using `glVertexAttributePointer()`:

````cpp
glVertexAttributePointer(0, 3, GL_FLOAT, GL_FALSE, 3*sizeof(float), (void)*0);
````

- First parameter specifies which vertex attribute we want to configure. In the shader, we specified `layout (location=0)`, hence we pass `0` as the location of the vertex attribute.
- The next argument specifies the size (number of values) of the vertex attribute, which is a `vec3` in our case.
- The 3rd argument specifies the type of data, which is `GL_FLOAT`.
- The 4th argument specifies if we want the data to be normalized, which is usually `false`.
- The 5th argument specifies the stride length, of the distance between each set of coordinates. Since each set of coordinates consists of 3 `float` values, the stride length will be 3 times `sizeof(float)`.
- The last parameter is of the type `(void*)` and thus requires the weird typecast. It specifies the offset of where the data begins in the buffer, which is `0` in our case.

Note that vertex attributes are disabled by default, so we have to enable it:

````cpp
glEnableVertexAttribArray(0);
````


### 6) Vertex array object (VAO)

All that steps just to draw a single object. Now imagine if we wanted to draw a hundred objects -- we would have to write all those code a hundred times.

Except we don't. A Vertex Array Object (VAO) can be bound just like a VBO. We can then switch between different vertex data and configurations as easily as binding a different VAO.

The process of generating a VAO looks familiar:

````cpp
GLuint VAO;
glGenVertexArrays(1, &VAO);
````

To use a VAO, we just have to bind it.

````cpp
glBindVertexArray(VAO);
````

### 7) Drawing triangle

Finally, we can draw the triangle.

````cpp
glUseProgram(shaderProgram);
glBindVertexArray(VAO);
glDrawArrays(GL_TRIANGLES, 0, 3);
````


## Element buffer object (EBO)

Since OpenGL mainly works with triangles, drawing a square would be the equivalent of drawing 2 triangles. However, to draw 2 triangles, we will have to define 6 vertices:

![[Pasted image 20241201203355.png#invert]]

````cpp
float vertices[] = 
{
	/* First triangle */
	-0.5, 0.5, 0.0,  // point 1
	0.5, 0.5, 0.0,   // point 2
	-0.5, -0.5, 0.0, // point 3 
	
	/* Second triangle */
	0.5, 0.5, 0.0,   // point 4
	-0.5, -0.5, 0.0, // point 5
	0.5, -0.5, 0.0   // point 6
};
````

Notice that points 2, 4 and 3, 5 are repeated. Is there a way to draw the 2 triangles sharing common points to avoid repetition?

We can use EBOs to store an array of indices telling OpenGL how to draw primitives using a set of vertices. This method is also referred to as **indexed drawing.**

We need to specify a list of unique vertices representing the corners of the square and another list representing the sequence to draw between the vertices.

````cpp
float vertices[] = {
     0.5f,  0.5f, 0.0f,  // top right
     0.5f, -0.5f, 0.0f,  // bottom right
    -0.5f, -0.5f, 0.0f,  // bottom left
    -0.5f,  0.5f, 0.0f   // top left 
};
GLuint indices[] = {  // starts from 0!
    0, 1, 3,   // first triangle
    1, 2, 3    // second triangle
};  
````

Next, create the element buffer object:

````cpp
GLuint EBO;
glGenBuffers(1, &EBO);
````

Similar to VBO, we need to bind the EBO and copy the indices into the buffer.

````cpp
glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
````

Now, instead of using `glDrawArrays()`, we need to use:

````cpp
glBindBiffer(GL_ELEMENT_ARRAY_BUFFER, EBO);
glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0)
````

The parameters specify the type of primitives to draw, number of indices, type of indices, and EBO offset. Note that `GL_UNSIGNED_INT` is used instead of something like `GLuint` since the former is a symbolic constant used to specify a data type in OpenGL while the latter is simply a typedef. 

We can configure OpenGL to draw elements in wireframe mode using:

````cpp
glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
````

To reset it to default mode:

````cpp
glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)
````

