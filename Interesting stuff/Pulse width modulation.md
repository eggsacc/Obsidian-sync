
Created <font style="color:tomato; font-family:Consolas;">2024-09-24</font>

Tags: #electronics #arduino

****

## Principle

The digital pins on the Arduino can only be toggled between 5V (HIGH) and 0V (LOW). So how do we achieve an intermediate voltage between 0-5V, to control, say, the brightness of an LED?

By switching the pin between 0V and 5V *really* fast, the pin can supply an "average voltage".

The example below show the pin being turned on 50% of one period. When this is done at a high frequency, the output will be the average voltage, which is 50% of 5V = 2.5V.

![[Pasted image 20240924195644.png]]

If we connect a LED between this pin and ground, we are turning the LED on half the time, and off the other half. At low frequencies, we just see the LED blinking; But when this happens sufficiently quickly (>30Hz), the flickering of the LED will be too fast for our eyes to catch and we just perceive it as being "half as bright".

>The 30Hz mentioned here is the threshold frequency for the persistence of vision effect in humans. Our eyes and brain retain a visual impression for ~1/30 of a second, so if the LED is blinking more than 30 times per second (30Hz), we perceive it as a continuous, intermediate brightness.

Another example with the pin turned on 25% of a period, which produced 25% of 5V = 1.25V.

![[Pasted image 20240924200030.png]]

The percentage of time the pin is turned 'on' is known as the **duty cycle**. We can control the output voltage by adjusting this parameter:

$$ Duty\; cycle=\frac{T_{ON}}{T_{ON}+T_{OFF}} \times 100\% $$
$$ V_{out}=Duty\; cycle \times V_{ON}$$

## PWM resolution

PWM resolution is the number of bits used to represent the duty cycle value. It is the number of discrete levels which the PWM duty cycle could be set to between 0-100%.

The Arduino uses 8-bit PWM. This means that there are $2^8=256$ subdivisions between 0-100% which the duty cycle could be adjusted to.

Let's say we want to slowly increase the brightness of an LED using PWM. If we choose a 3-bit PWM, there would only be $2^3=8$ "steps" between 0-100%, and the process of turning on the LED will look very choppy since there are only 8 discrete brightness levels the LED can display. If we increase the resolution to say 7-bits, there would instead be $2^7=128$ "steps", and hence 128 discrete levels of brightness the LED can display when transitioning from unlit to fully lit, which looks much smoother.

So is it optimal to just make the PWM resolution as high as possible? To answer that, we first need to understand how microcontrollers generate PWM.

## Generating PWM

You may think that PWM is generated by turning the pin 'on' and 'off' for specific periods of time in software, but this is actually not desirable despite being plausible. 

PWM generation is often handled by special hardware registers and interrupts instead.

>Registers are memory locations built into the processor itself, making it extremely accessible but also limited in storage size. Hardware registers are special registers where each bit stored in these registers modifies the state of some hardware. For instance, saving the binary 1001 in the PORTB register of an Arduino UNO turns pins 8, 11 on.

### Timers

Every microcontroller has built-in timers and an internal or external resonator which sets the frequency of operation. The Arduino UNO, for example, operates at 16Mhz and has 3 hardware timers. By default, these timers will increment it's stored value by 1 every clock tick.

These hardware timers could be configured to count in a different manners. Below is some basic timer knowledge:

1) **Size**: the maximum number of bits the timer register can hold. For the Arduino UNO, it has 2x 8-bit timers and 1x 16-bit timer.

2) **Pre-scalar**: how many internal clock ticks before counting up by 1. Sometimes we don't want the timers so count so fast, so we can set it to count up by 1 for every 8 clock ticks etc.

3) **TOP value:** a TOP value is a premature endpoint that could be specified. The TOP value is set to the size of each timer by default; E.g an 8-bit timer will have a TOP of 255 by default, but we can manually set it to say 156 instead, and it will only count till 156 before resetting.

4) **Mode:** how the timer behaves after reaching TOP value (also called a timer overflow). By default, the timer will restart from 0 and count up again. It could be configured such that the timer starts counting down instead, or restart from a set value instead of 0.

### Interrupts

Interrupts are signals that temporarily halts the execution of the main program to tend to some time-sensitive tasks or respond to external events. For example, we can enable an interrupt when data is received from a sensor on the Arduino. The Arduino will pause the main code and read the sensor values during the interrupt routine, and resume once it finishes.

There are specific interrupt registers that could turn a pin `ON` or `OFF` based on an event. In the case of PWM generation, we can set some interrupt register to trigger when the timer counts to a specific value.

### Working together

This is how we can generate a 8-bit PWM using only hardware timers and interrupts:

1) Choose an 8-bit timer and set it's mode to reset on overflow. We will choose `timer2` on the Arduino UNO since it is 8-bit.

2) Enable an interrupt register to **toggle** the pin state whenever `timer2` reaches a specific value `n` , and also when reaching the TOP value.

The graph below shows `timer2`  counting from 0 to it's TOP value (255 default), and the interrupt value `n`.

![[Pasted image 20240924213433.png]]

Below is resulting voltage output from the pin being toggled `ON` and `OFF`. 

![[Pasted image 20240924213930.png]]

Now let's change the interrupt value `n` to a larger value:

![[Pasted image 20240924214020.png]]

